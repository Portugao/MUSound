<?php
/**
 * MUSound.
 *
 * @copyright Michael Ueberschaer (MU)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package MUSound
 * @author Michael Ueberschaer <kontakt@webdesign-in-bremen.com>.
 * @link http://webdesign-in-bremen.com
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.6.2 (http://modulestudio.de).
 */

/**
 * Event handler implementation class for dispatching modules.
 */
class MUSound_Listener_ModuleDispatch extends MUSound_Listener_Base_ModuleDispatch
{
    /**
     * Listener for the `module_dispatch.postloadgeneric` event.
     *
     * Called after a module api or controller has been loaded.
     * Receives the args `array('modinfo' => $modinfo, 'type' => $type, 'force' => $force, 'api' => $api)`.
     *
     * @param Zikula_Event $event The event instance.
     */
    public static function postLoadGeneric(Zikula_Event $event)
    {
        parent::postLoadGeneric($event);
    
        // you can access general data available in the event
        
        // the event name
        // echo 'Event: ' . $event->getName();
        
        // type of current request: MASTER_REQUEST or SUB_REQUEST
        // if a listener should only be active for the master request,
        // be sure to check that at the beginning of your method
        // if ($event->getRequestType() !== HttpKernelInterface::MASTER_REQUEST) {
        //     // don't do anything if it's not the master request
        //     return;
        // }
        
        // kernel instance handling the current request
        // $kernel = $event->getKernel();
        
        // the currently handled request
        // $request = $event->getRequest();
    }
    
    /**
     * Listener for the `module_dispatch.preexecute` event.
     *
     * Occurs in `ModUtil::exec()` after function call with the following args:
     *     `array('modname' => $modname,
     *            'modfunc' => $modfunc,
     *            'args' => $args,
     *            'modinfo' => $modinfo,
     *            'type' => $type,
     *            'api' => $api)`
     * .
     *
     * @param Zikula_Event $event The event instance.
     */
    public static function preExecute(Zikula_Event $event)
    {
        parent::preExecute($event);
    
        // you can access general data available in the event
        
        // the event name
        // echo 'Event: ' . $event->getName();
        
        // type of current request: MASTER_REQUEST or SUB_REQUEST
        // if a listener should only be active for the master request,
        // be sure to check that at the beginning of your method
        // if ($event->getRequestType() !== HttpKernelInterface::MASTER_REQUEST) {
        //     // don't do anything if it's not the master request
        //     return;
        // }
        
        // kernel instance handling the current request
        // $kernel = $event->getKernel();
        
        // the currently handled request
        // $request = $event->getRequest();
    }
    
    /**
     * Listener for the `module_dispatch.postexecute` event.
     *
     * Occurs in `ModUtil::exec()` after function call with the following args:
     *     `array('modname' => $modname,
     *            'modfunc' => $modfunc,
     *            'args' => $args,
     *            'modinfo' => $modinfo,
     *            'type' => $type,
     *            'api' => $api)`
     * .
     * Receives the modules output with `$event->getData();`.
     * Can modify this output with `$event->setData($data);`.
     *
     * @param Zikula_Event $event The event instance.
     */
    public static function postExecute(Zikula_Event $event)
    {
        parent::postExecute($event);
    
        // you can access general data available in the event
        
        // the event name
        // echo 'Event: ' . $event->getName();
        
        // type of current request: MASTER_REQUEST or SUB_REQUEST
        // if a listener should only be active for the master request,
        // be sure to check that at the beginning of your method
        // if ($event->getRequestType() !== HttpKernelInterface::MASTER_REQUEST) {
        //     // don't do anything if it's not the master request
        //     return;
        // }
        
        // kernel instance handling the current request
        // $kernel = $event->getKernel();
        
        // the currently handled request
        // $request = $event->getRequest();
        
        $isAvailable = ModUtil::available('MUSound');
        
        $modargs = $event->getArgs();
        
        if (in_array($modargs['modname'], array('Blocks', 'Admin', 'MUSound'))) {
        	// nothing to do for module blocks, admin and musound
        	return;
        }
        
        if ($modargs['type'] == 'admin') {
        	// admin call, thus nothing to do
        	return;
        }
        
        // check if MUSound is activated for any modules
        $modules = MUSound_Api_User::checkModules();
        if (!is_array($modules) || count($modules) < 1) {
        	// no active modules, thus nothing to do
        	return;
        }
        
        // we are not interested in api functions
        if ($modargs['api'] == 1) {
        	return;
        }
        
        $controllers = array('display');
        
        if($modargs['modname'] == 'Content' || $modargs['modname'] == 'News') {
        	$controllers[] = 'view';
        }
        
        if ($modargs['modname'] == 'Content') {
        	$controllers[] = 'pagelist';
        }
        if ($modargs['modname'] == 'Clip') {
        	$controllers[] = 'list';
        }
        
        if (!in_array($modargs['modfunc'][1], $controllers)) {
        	// unallowed controller, thus nothing to do
        	return;
        }
        
        
        $request = new Zikula_Request_Http();
        $module = $request->query->filter('module', 'MUSound', FILTER_SANITIZE_STRING);
        
        if (($modargs['modname'] == $module && in_array($modargs['modname'], $modules) || $module == 'MUSound') && $isAvailable === true) {
        
        	/*function replacePatternMUSound($treffer)
        	{
        		$albumId = $treffer[2];
        		$albumrepository = MUSound_Util_Model::getAlbumRepository();
        		$album = $albumrepository->selectById($albumId);
        		if (is_object($album)) {


        				return "<div id='wrapper2'></div>
  
<script type='text/javascript'>
/* <![CDATA[ */
    /*var MU = jQuery.noConflict();
    jQuery(document).ready(function(){

    var myPlaylist = [
    {{foreach name=albumtracks item=track from=$album.tracks}}
        {
            oga:'',
            mp3:'{{$track->uploadTrackFullPathUrl}}',
            title:'{{$track->title}}',
            artist:'{{if $track->author ne ''}}{{$track->author}}{{else}}{{$track->album->author}}{{/if}}',
            cover:'{{if $track->album->uploadCoverFullPathUrl}}{{$track->album->uploadCoverFullPathUrl}}{{else}}/modules/MUSound/images/NoCover.jpg{{/if}}'
        }{{if $smarty.foreach.albumtracks.last ne true}},{{/if}}
    {{/foreach}}
    ];
            var description = '{{$track->album->description}}';

            MU('#wrapper2').ttwMusicPlayer(myPlaylist, {
                autoPlay:false, 
                description:description,
                jPlayer:{
                    swfPath:'/modules/MUSound/lib/vendor/musicplayer/jquery-jplayer/' //You need to override the default swf path any time the directory structure changes
                }
            });
      

    
    });
/* ]]> */
//</script>";
        	/*} else {
        				return '';
        			}
        	}*/
        	$data = $event->getData();
        
        	$pattern = '(MUSOUNDALBUM)\[([0-9]*)\]';
        	$newData = preg_replace_callback("/$pattern/",         	function ($treffer)
        	{
        		$albumId = $treffer[2];
        		$albumrepository = MUSound_Util_Model::getAlbumRepository();
        		$album = $albumrepository->selectById($albumId);
        		if (is_object($album)) {


        				return "<div id='wrapper2'></div>
  
<script type='text/javascript'>
/* <![CDATA[ */
    var MU = jQuery.noConflict();
    jQuery(document).ready(function(){

    var myPlaylist = [
    {{foreach name=albumtracks item=track from=$album.tracks}}
        {
            oga:'',
            mp3:'{{$track->uploadTrackFullPathUrl}}',
            title:'{{$track->title}}',
            artist:'{{if $track->author ne ''}}{{$track->author}}{{else}}{{$track->album->author}}{{/if}}',
            cover:'{{if $track->album->uploadCoverFullPathUrl}}{{$track->album->uploadCoverFullPathUrl}}{{else}}/modules/MUSound/images/NoCover.jpg{{/if}}'
        }{{if $smarty.foreach.albumtracks.last ne true}},{{/if}}
    {{/foreach}}
    ];
            var description = '{{$track->album->description}}';

            MU('#wrapper2').ttwMusicPlayer(myPlaylist, {
                autoPlay:false, 
                description:description,
                jPlayer:{
                    swfPath:'/modules/MUSound/lib/vendor/musicplayer/jquery-jplayer/' //You need to override the default swf path any time the directory structure changes
                }
            });
      

    
    });
/* ]]> */
</script>";
        	} else {
        				return '';
        			}
        	}, $data);
        	$event->setData($newData);
        		
        } else {
        	// nothing to do
        }
    }
    
    /**
     * Listener for the `module_dispatch.custom_classname` event.
     *
     * In order to override the classname calculated in `ModUtil::exec()`.
     * In order to override a pre-existing controller/api method, use this event type to override the class name that is loaded.
     * This allows to override the methods using inheritance.
     * Receives no subject, args of `array('modname' => $modname, 'modinfo' => $modinfo, 'type' => $type, 'api' => $api)`
     * and 'event data' of `$className`. This can be altered by setting `$event->setData()` followed by `$event->stop()`.
     *
     * @param Zikula_Event $event The event instance.
     */
    public static function customClassname(Zikula_Event $event)
    {
        parent::customClassName($event);
    
        // you can access general data available in the event
        
        // the event name
        // echo 'Event: ' . $event->getName();
        
        // type of current request: MASTER_REQUEST or SUB_REQUEST
        // if a listener should only be active for the master request,
        // be sure to check that at the beginning of your method
        // if ($event->getRequestType() !== HttpKernelInterface::MASTER_REQUEST) {
        //     // don't do anything if it's not the master request
        //     return;
        // }
        
        // kernel instance handling the current request
        // $kernel = $event->getKernel();
        
        // the currently handled request
        // $request = $event->getRequest();
    }
    
    /**
     * Listener for the `module_dispatch.service_links` event.
     *
     * Occurs when building admin menu items.
     * Adds sublinks to a Services menu that is appended to all modules if populated.
     * Triggered by module_dispatch.postexecute in bootstrap.
     *
     * @param Zikula_Event $event The event instance.
     */
    public static function serviceLinks(Zikula_Event $event)
    {
        parent::customClassName($event);
    
        // Format data like so:
        // $event->data[] = array('url' => ModUtil::url('MUSound', 'user', 'main'), 'text' => __('Link Text'));
    
        // you can access general data available in the event
        
        // the event name
        // echo 'Event: ' . $event->getName();
        
        // type of current request: MASTER_REQUEST or SUB_REQUEST
        // if a listener should only be active for the master request,
        // be sure to check that at the beginning of your method
        // if ($event->getRequestType() !== HttpKernelInterface::MASTER_REQUEST) {
        //     // don't do anything if it's not the master request
        //     return;
        // }
        
        // kernel instance handling the current request
        // $kernel = $event->getKernel();
        
        // the currently handled request
        // $request = $event->getRequest();
    }
}
